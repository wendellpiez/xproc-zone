<html xmlns="http://www.w3.org/1999/xhtml"><head><title>XProc from Orbit</title></head><body><section><h1>XProc from Orbit</h1><blockquote>
<p>Material in draft!</p>
</blockquote><p>From a height you can see broader outlines.</p><p>XProc is a data processing technology for digital data. While it is an XML-based technology using XML syntax, it can work with many kinds of data, including common text-based formats such as JSON.</p><p>In XProc, information processing happens by means of <em>pipelines</em>. Expressed using XML format, an XProc pipeline is both a linguistic and computational artifact, and (in developers' minds) a discrete logical entity with an internal organization: a chain or branched structure.</p><p>A pipeline combines a sequence or set of processes and applies them to specified inputs ("sources") to create outputs ("results").</p><p>This makes XProc an appropriate technology for building and supporting complex workflows in document production, data conversion, and information exchange.</p><section><h2>Pipelines and steps</h2><ul>
<li>A pipeline is made of steps</li>
<li>A pipeline can also be used as a step, when declared with or imported into another pipeline</li>
<li>XProc defines libraries of standard, reusable steps for all processors, supporting many common operations</li>
<li>You can also design and use new steps, in and with your own XProc</li>
</ul><div class="eg_block"><h5 class="eg_label">Example <a class="eg_link" href="../surface/starter.xpl">surface/starter.xpl</a></h5><pre class="transclude" id="example_surface/starter">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;p:declare-step version="3.0" xmlns:p="http://www.w3.org/ns/xproc"&gt;
  &lt;!-- A pipeline is defined with p:declare-step --&gt;
  
  &lt;!-- First, reads a file from the file system --&gt;
  &lt;p:load href="../xproc-from-orbit.md" content-type="text/plain"/&gt;
  
  &lt;!-- Does its best to produce HTML from Markdown input --&gt;
  &lt;p:markdown-to-html/&gt;

  &lt;!-- Saves the result --&gt;
  &lt;p:store href="../out/xproc-from-orbit.html"/&gt;
  
&lt;/p:declare-step&gt;
</pre></div><div class="eg_block"><h5 class="eg_label">Example <a class="eg_link" href="../surface/make-page.xpl">surface/make-page.xpl</a></h5><pre class="transclude" id="example_surface/make-page">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;p:declare-step version="3.0"
  xmlns:p="http://www.w3.org/ns/xproc"
  xmlns:zone="http://wendellpiez.com/ns/xproc-zone"&gt;
  
  &lt;!--  Imports a pipeline (step declaration or library) --&gt;
  &lt;p:import href="_enhance-md-html.xpl"/&gt;
  
  &lt;!-- Loads a file as plain text --&gt;
  &lt;p:load href="../xproc-from-orbit.md" content-type="text/plain"/&gt;
  
  &lt;!-- Makes HTML, if possible (supported in XML Calabash) --&gt;
  &lt;p:markdown-to-html/&gt;

  &lt;!-- Calls an imported step --&gt;
  &lt;zone:enhance-md-html/&gt;
  
  &lt;!-- Saves the result --&gt;
  &lt;p:store href="../out/xproc-from-orbit.html"
    serialization="map { 'method': 'xml', 'omit-xml-declaration': true() }"/&gt;
  
&lt;/p:declare-step&gt;
</pre></div></section><section><h2>How to write a pipeline</h2><p>An XProc pipeline takes the form of an arrangement of steps.</p><div class="eg_block"><h5 class="eg_label">Example <a class="eg_link" href="../surface/moresteps.xpl">surface/moresteps.xpl</a></h5><pre class="transclude" id="example_surface/moresteps">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;p:declare-step version="3.0" xmlns:p="http://www.w3.org/ns/xproc"&gt;
  
  &lt;!-- Reads a file as plain text --&gt;
  &lt;p:load href="../xproc-from-orbit.md" content-type="text/plain"/&gt;
  
  &lt;!-- If the processor supports the step, Markdown is converted to HTML --&gt;
  &lt;p:markdown-to-html/&gt;

  &lt;!-- Applying an XSLT transformation using the nominated stylesheet --&gt;
  &lt;p:xslt&gt;
    &lt;p:with-input port="stylesheet" href="html-enhance.xsl"/&gt;
  &lt;/p:xslt&gt;
  
  &lt;!-- Saves a file in the ../out folder --&gt;
  &lt;p:store href="../out/xproc-from-orbit.html"/&gt;
  
&lt;/p:declare-step&gt;
</pre></div><p>We say 'arrangement' here since steps can accommodate as many inputs and outputs as needed, connecting together.</p><p>[Illustration: a more complex pipeline]</p></section></section><section><h1>XProc from Above</h1><section><h2>I/O, ports and documents</h2><ul>
<li>Pipelines, and steps, can accept one or more designated inputs, or none - they can accept inputs provided at runtime, or find and load data sources, or both</li>
<li>Steps can also expose processing results as outputs, and also interact with your system, writing files on disk or communicating through other channels</li>
<li>The connections that an XProc step exposes for data are called its <strong>ports</strong></li>
<li>By means of ports, we pass documents into steps and get documents out - and while XProc calls them <strong>documents</strong>, they can be any kind of data at all</li>
<li>A pipeline can be defined with ports for connecting with other steps, when used as a step in another pipeline</li>
<li>The <em>composability</em> of steps is key to the efficiency and power offered by XProc</li>
</ul><p>[illustration: validation step, w/ four ports]</p></section><section><h2>Steps with implicit port connections</h2><ul>
<li>XProc syntax is commonly abbreviated so you don't see ports that can be assumed to be there by the rules</li>
<li>This means most of the steps you use within a pipeline work together, in sequence -- <em>not</em> autonomously and independently of one another, even if this is the case with the pipeline that contains them.</li>
</ul><p>[illustrations: three steps in sequence, with and without ports showing]</p></section><section><h2>How to call a step</h2><p>One type of step with a single input port is <code>p:identity</code> - it produces a document (or sequence of documents) without changes, on its single output port.</p><p>A step with two input ports is <code>p:xslt</code> - it accepts source documents on one port (<code>source</code>) and a stylesheet on another port (<code>stylesheet</code>), applies a transformation (based on the stylesheet) to the source documents, and produces a sequence of result documents on an output port, one for each of the sources.</p><p>[illustration: three steps in sequence, including an xslt step]</p><p>Steps have names and types. Their type is what you see (<code>add attribute</code>, <code>identity</code>, <code>xslt</code>) and what you use to call them. Since they are called by type, steps can be anonymous. ("What they do" is considered to depend on their type.)</p><p>When you use a step in a pipeline, however, you can also give it a name, this making it possible to connect other steps to it, out of sequence as well as in sequence.</p><p><a href="`p:with-input`">../../docs/xproc-lab/zone-xproc-index.html#with-input</a> is the element to look at for this.</p></section><section><h2>Knowing your formats</h2><p>XProc comes with native support for XML and JSON reading and parsing, for plain text inputs, and for inputs defined with regular grammars using <a href="https://invisiblexml.org">Invisible XML (ixml)</a>.</p><p>All of these types of data, and others, can be passed from one step to another, as long as the step can accommodate the given format or media type.</p><p>[illustration: a step showing some JSON]</p></section><section><h2>Powerful embedded languages</h2><p>XPath, XSLT and XQuery all play well with XProc, which is designed first and foremost to accommodate these kindred technologies.</p><p>XProc steps can either invoke or embed instances of these declarative processing languages, or others.</p><p>[illustration: a step showing some XQuery?]</p></section><section><h2>Looking at those ports</h2><p>Ports go only one direction - they are either <strong>input</strong>, or <strong>output</strong> (never both, neither or anything else).</p><p>Any input port can be <em>primary</em> on its step, or <em>secondary</em>. (No 'tertiary'.) Same for output ports.</p><p>A step can have at most a single primary input port and primary output port. All input ports that are not primary, are secondary.</p><p>The primary input port is usually named <code>source</code> (by convention). Secondary ports commonly have names based on their role in the step (e.g., <code>schema</code>).</p><p>The primary output port is usually named <code>result</code> (by convention). Secondary output ports will also be given descriptive names (e.g., <code>report</code>).</p><p>Either type of port can also accept sequences, that is to say, a step can be defined such that <em>multiple</em> documents are expected on a port. This is very useful in XProc with steps designed to sift, split or merge data streams, as well as providing opportunities for parallel processing.</p><p>The conventional names for the primary ports <code>source</code> (for input) and <code>result</code> (for output) are handy because they correspond with other technical uses of those terms.</p></section><section><h2>Reflection</h2><p>A step with no input ports may nonetheless have inputs or dependencies, loading documents and data from outside the pipeline. This is a design feature of the language, and not in itself wrong or ill-advised.</p><p>Similarly a useful step may also have no output ports, or a port showing only tracebacks to a user to confirm operations at runtime (for example, on a terminal). Nonetheless it can build web sites, write results of data conversions to online or offline data stores, etc. - and we call these "side effects" even when they are the point of the exercise.</p><p>Then too, the entire reason to have ports is to pass data into and through the pipelines that declare them -- information sets that must start and end somewhere.</p><p>This two-sided power - that it is both a declarative and functional language whose operations are largely <em>abstracted</em>, and also an information processing engine that reads and writes data, is key to what makes XProc useful.</p><p>Think of it as nested black boxes, except with labeled hatches, and unlocked, with spot lighting and schematics available.</p><p>We put XProc to work reading and transforming data - in specified, testable ways - but we think of it in abstract terms that enable most of the chores (especially those related to memory and resource management) to be delegated to the processing engine to take care of.</p></section><section><h2>Those implicit connections</h2><p>As mentioned, steps can always connect using implicit connections, even when they are anonymous (have no name to connect to).</p><p>This is possible due to a rule of processing: the XProc engine should assume, unless when given indications otherwise, that a primary input port will connect to the immediately preceding step's primary output port.</p><p>Consequently, an XProc pipeline can be designed as a straight sequence of steps, each of which hands off its results to the next step. These can be long, while remaining simple to construct and maintain.</p><p>The pipeline is simple but the operations within any step can be arbitrarily complex, especially if the step logic is implemented in a full-fledged data processing language such as XSLT or XQuery.</p></section><section><h2>Explicit connections</h2><p>If processing requirements are too complex to address with a simple chain or sequence of steps, steps can be named and connections made to other steps, by binding to their ports by name.</p><p>The XProc Index to XProc in the XProc Zone shows examples of <a href="zone-xproc-index.html#with-input">p:with-input</a>, to illustrate.</p></section><section><h2>Options</h2><p>In addition to inputs and outputs (connection ports), steps can also have <strong>options</strong>.</p><p>These provide runtime configurations when invoking steps and pipelines.</p><p>Their values can be simple (string value flags) or complex (such as map objects, or expressions to be evaluated).</p><p>Its ports and options together provide an <em>interface</em> for using a step.</p><p>Options can be set on steps using abbreviated syntax (attributes) or long syntax (<code>p:with-option</code>)</p></section><section><h2>Connectors</h2><p>There are a few elements in XProc that work not as steps, but to provide the connections between the steps - the connectors. p:inline p:empty p:document p:pipe</p></section><section><h2>Minimal XProc</h2><p>If your skills include XSLT, this might be all you ever need in XProc:</p><ul>
<li><code>p:variable</code></li>
<li><code>p:load</code></li>
<li><code>p:store</code></li>
<li><code>p:xslt</code></li>
<li><code>@serialization</code></li>
<li><code>@message</code></li>
</ul><p>Take another lesson on Day Two - learn to write a pipeline and use it as a step</p><ul>
<li><code>p:declare-step</code></li>
<li><code>p:input</code> (and <code>p:with-input</code>)</li>
<li><code>p:output</code></li>
<li><code>p:option</code> and (<code>p:with-option</code>)</li>
<li><code>p:library</code></li>
</ul><p>Three everyday utility steps</p><ul>
<li><code>p:sink</code></li>
<li><code>p:cast-content-type</code></li>
<li><code>p:identity</code></li>
</ul><p><a href="xproc-step-list.html">Step list</a></p></section></section></body></html>