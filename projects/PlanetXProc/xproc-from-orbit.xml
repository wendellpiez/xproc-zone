<?xml version="1.0" encoding="UTF-8"?>
<body xmlns="http://www.tei-c.org/ns/1.0" xmlns:xi="http://www.w3.org/2001/XInclude">
   <div>
      <head>XProc from Orbit</head>
      <p>XProc is a data processing technology for digital data. While it is an XML-based technology using XML syntax, it can work with many kinds of data, including common text-based formats such as JSON.</p>
      <p>As a language, XProc describes <emph rend="bold">pipelines</emph>. A pipeline combines a sequence or set of processes and applies them to specified inputs ("sources") to create outputs ("results").</p>
      <p>Use XProc to build support complex workflows in document production, data conversion, and information exchange.</p>
      <div>
         <head>Pipelines and steps</head>
         <list>
            <item>A pipeline is made of steps</item>
            <item>A pipeline can also be used as a step, when declared with or imported into another pipeline</item>
            <item>XProc defines libraries of standard, reusable steps for all processors, supporting many common operations</item>
            <item>You can also design and use new steps, in and with your own XProc</item>
         </list>
         <figure source="src/starter.xpl">
            <head type="gloss">A simple pipeline with three steps.</head>
            <eg>
               <xi:include parse="text" href="src/starter.xpl"/>
            </eg>
         </figure>
         <figure source="src/producer.xpl">
            <head type="gloss">Four steps, including an imported step named with a developer's (project) namespace.</head>
            <eg>
               <xi:include parse="text" href="src/producer.xpl"/>
            </eg>
         </figure>
      </div>
      <div>
         <head>How to write a pipeline</head>
         <p>An XProc pipeline takes the form of an arrangement of steps.</p>
         <figure source="src/moresteps.xpl">
            <eg>
               <xi:include parse="text" href="src/moresteps.xpl"/>
            </eg>
         </figure>
         <p>We say 'arrangement' here since steps can accommodate as many inputs and outputs as needed, connecting together.</p>
         <figure source="src/double-validate.xpl">
            <eg>
               <xi:include parse="text" href="src/double-validate.xpl"/>
            </eg>
         </figure>
      </div>
   </div>
   <div>
      <head>XProc From 40,000 Feet</head>
      <div>
         <head>I/O, ports and documents</head>
         <list>
            <item>Pipelines, and steps, can accept one or more designated inputs, or none - they can accept inputs provided at runtime, or find and load data sources, or both, or generate their own</item>
            <item>Steps can also expose processing results as outputs, and also interact with your system, writing files on disk or communicating through other channels</item>
            <item>The connecting points on an XProc step are called its <emph rend="bold">ports</emph>
            </item>
            <item>By means of ports, we pass documents into steps and get documents out - and while XProc calls them <emph rend="bold">documents</emph>, they can be pretty much any kind of data</item>
            <item>A pipeline can be defined with ports for connecting with other steps, when used as a step in another pipeline</item>
            <item>The <hi rend="italic">composability</hi> of steps is key to the efficiency and power offered by XProc</item>
         </list>
         <figure source="src/double-validate.xpl">
            <head type="gloss">This pipeline validates its input twice and collects validation reports into a single document.</head>
            <eg>
               <xi:include parse="text" href="src/double-validate.xpl"/>
            </eg>
         </figure>
      </div>
      <div>
         <head>Ports, steps, sources and results</head>
         <p>Ports go in only one direction: they are for <emph rend="bold">input</emph> or <emph rend="bold">output</emph>, never both. One of the input ports will be designated as <emph rend="bold">primary</emph>, while others are <emph rend="bold">secondary</emph>. Similarly, one and only one of the output ports may be designated as primary. Not all steps have secondary ports, but some steps make little sense without them.</p>
         <p>The conventional name for the primary <hi rend="italic">input</hi> port is <code>source</code>. The conventional name for the primary <hi rend="italic">output</hi> port is <code>result</code>. These names correspond with the uses of these terms in XSLT and XQuery.</p>
         <p>It is sometimes useful for a step to have output but no input (like <code>p:load</code>), or input with no output (like <code>p:sink</code>). And not all steps produce modifications of inputs among their outputs. For example, <code>p:directory-list</code> has no input but produces XML on its <code>result</code> port listing the contents of a file system directory.</p>
         <p>The <code>source</code> and <code>result</code> ports can carry <hi rend="italic">sequences</hi> when they are defined as such on their steps - and when permitted to be sequences they may also be <hi rend="italic">empty</hi>, with no documents bound to them.</p>
         <p>Unlike the primary ports (likely named <code>source</code> and <code>result</code>), secondary ports are given names indicating the roles they play for their steps. Good examples include the <code>schema</code> secondary input port on validation steps, which a processor uses to provide a schema, or the <code>insertion</code> port on the <code>p:insert</code> step, for the data to be inserted.</p>
      </div>
      <div>
         <head>Steps with implicit port connections</head>
         <p>XProc syntax can be fairly concise and clean - at least, as XML-based formats go - because it has sensible fallback rules and some nice ways of keeping syntax simple.</p>
         <p>One important example: as long as steps in your pipeline are to be applied in sequence, their connections do not have to be shown. It has been suggested they <hi rend="italic">snap together</hi>.</p>
         <p>The XProc feature in play here is called the <ref target="https://spec.xproc.org/3.0/xproc/#connecting-the-drp">default readable port</ref>. The concept is simple. Any step with a primary input port that is not connected explicitly, will be bound to the primary output of the immediately preceding step.</p>
         <p>This works well, with the caveat that steps that have no input ports don't connect like this, even when given in sequence - and steps with no output ports can't be connected as inputs at all. Know your steps.</p>
         <figure source="src/moresteps.xpl">
            <eg>
               <xi:include parse="text" href="src/moresteps.xpl"/>
            </eg>
         </figure>
         <figure source="src/moresteps-explicit.xpl">
            <head type="gloss">The same pipeline, with connections spelled out.</head>
            <eg>
               <xi:include parse="text" href="src/moresteps-explicit.xpl"/>
            </eg>
         </figure>
      </div>
      <div>
         <head>Knowing your formats</head>
         <p>XProc comes with native support for XML and JSON reading and parsing, for plain text inputs, and for inputs defined with regular grammars using <ref target="https://invisiblexml.org">Invisible XML (ixml)</ref>.</p>
         <p>All of these types of data, and others, can be passed from one step to another, as long as both steps can accommodate the given format or media type.</p>
         <figure source="src/read-json.xpl">
            <head type="gloss">With map and array object types, XPath 3.0/3.1 supports JSON natively.</head>
            <eg>
               <xi:include parse="text" href="src/read-json.xpl"/>
            </eg>
         </figure>
      </div>
      <div>
         <head>Powerful embedded languages</head>
         <p>XPath, XSLT and XQuery all play well with XProc, which is designed first and foremost to accommodate these kindred technologies.</p>
         <p>XProc steps can either invoke or embed instances of these declarative processing languages, or others.</p>
         <figure source="src/some-xquery.xpl">
            <eg>
               <xi:include parse="text" href="src/some-xquery.xpl"/>
            </eg>
         </figure>
      </div>
      <div>
         <head>Options</head>
         <p>In addition to inputs and outputs (connection ports), steps can also have <emph rend="bold">options</emph>.</p>
         <p>These provide runtime configurations when invoking steps and pipelines.</p>
         <p>For some steps, certain options are required, for example to designate which nodes to delete on a <code>p:delete</code> step (using the <code>match</code> option).</p>
         <p>Values assigned to options can be simple (string value flags) or complex (such as map objects, or expressions to be evaluated).</p>
         <p>Its ports and options together provide an <hi rend="italic">interface</hi> for using a step.</p>
         <p>Options can be set on steps using abbreviated syntax (attributes) or long syntax (<code>p:with-option</code>)</p>
         <figure source="src/test-landing.xpl">
            <head type="gloss">Parameters are sent to the stylesheet using an XProc option (in attribute syntax).</head>
            <eg>
               <xi:include parse="text" href="src/test-landing.xpl"/>
            </eg>
         </figure>
      </div>
      <div>
         <head>Foundations of XProc</head>
         <p>The more you know, the better you feel.</p>
         <list>
            <item>XML syntax</item>
            <item>XML namespaces</item>
            <item>XPath (including XPath 3.0, 3.1) and XDM (XML Data Model)</item>
            <item>XSLT, XQuery</item>
            <item>REST and the web / URIs</item>
            <item>schema technologies, standard vocabularies, validation and workflow</item>
            <item>HTML/CSS/SVG, XSL-FO</item>
         </list>
      </div>
      <div>
         <head>Minimal XProc</head>
         <p>If your skills include XSLT, this might be all you ever need in XProc:</p>
         <list>
            <item>
               <code>p:declare-step</code>
            </item>
            <item>
               <code>p:variable</code>
            </item>
            <item>
               <code>p:load</code>
            </item>
            <item>
               <code>p:store</code>
            </item>
            <item>
               <code>p:xslt</code>
            </item>
            <item>
               <code>@serialization</code>
            </item>
            <item>
               <code>@message</code>
            </item>
         </list>
         <p>Take another lesson on Day Two - learn to write a pipeline and use it as a step</p>
         <list>
            <item>
               <code>p:declare-step/@type</code>
            </item>
            <item>
               <code>p:input</code> and <code>p:with-input</code>
            </item>
            <item>
               <code>p:output</code>
            </item>
            <item>
               <code>p:option</code> and <code>p:with-option</code>
            </item>
            <item>
               <code>p:library</code>
            </item>
         </list>
         <p>Three everyday utility steps</p>
         <list>
            <item>
               <code>p:sink</code>
            </item>
            <item>
               <code>p:cast-content-type</code>
            </item>
            <item>
               <code>p:identity</code>
            </item>
         </list>
      </div>
   </div>
</body>
